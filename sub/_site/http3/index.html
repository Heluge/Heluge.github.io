<!DOCTYPE html> <html lang="en-US"> <head prefix="og: http://ogp.me/ns#"> <meta charset="UTF-8" /> <meta http-equiv="X-UA-Compatible" content="ie=edge" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <meta name="mobile-web-app-capable" content="yes" /> <meta name="apple-mobile-web-app-capable" content="yes" /> <meta name="application-name" content="Heluge's blog" /> <meta name="apple-mobile-web-app-status-bar-style" content="#fff" /> <meta name="apple-mobile-web-app-title" content="Heluge's blog" /> <title> Nouveautés introduites par HTTP/3 - Heluge's blog </title> <link rel="alternate" href="https://klise.now.sh/http3/" hreflang="en-US" /> <link rel="canonical" href="https://klise.now.sh/http3/" /> <meta name="description" content="He&#39;s writing in Bahasa about web technology and experience as a journal for documentation things that he learned, meet him @github." /> <meta name="referrer" content="no-referrer-when-downgrade" /> <meta property="fb:app_id" content="" /> <meta property="og:site_name" content="Nouveautés introduites par HTTP/3 | Julie Hazan" /> <meta property="og:title" content="Nouveautés introduites par HTTP/3 | Julie Hazan" /> <meta property="og:type" content="website" /> <meta property="og:url" content="https://klise.now.sh/http3/" /> <meta property="og:description" content="He&#39;s writing in Bahasa about web technology and experience as a journal for documentation things that he learned, meet him @github." /> <meta property="og:image" content="https://klise.now.sh/assets/img/ogp.png" /> <meta property="og:image:width" content="640" /> <meta property="og:image:height" content="640" /> <meta name="twitter:card" content="summary" /> <meta name="twitter:title" content="Nouveautés introduites par HTTP/3 | twitter_username" /> <meta name="twitter:url" content="https://klise.now.sh/http3/" /> <meta name="twitter:site" content="@twitter_username" /> <meta name="twitter:creator" content="@twitter_username" /> <meta name="twitter:description" content="He&#39;s writing in Bahasa about web technology and experience as a journal for documentation things that he learned, meet him @github." /> <meta name="twitter:image" content="https://klise.now.sh/assets/img/ogp.png" /> <link type="application/atom+xml" rel="alternate" href="https://klise.now.sh/feed.xml" title="Heluge&apos;s blog" /> <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-touch-icon.png" /> <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png" /> <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png" /> <link rel="manifest" href="/assets/favicons/site.webmanifest" /> <link rel="mask-icon" href="/assets/favicons/safari-pinned-tab.svg" color="#5bbad5" /> <meta name="apple-mobile-web-app-title" content="Jekyll Klise" /> <meta name="application-name" content="Jekyll Klise" /> <meta name="msapplication-TileColor" content="#da532c" /> <meta name="theme-color" content="#2c2c2c" /> <link rel="stylesheet" href="/assets/css/style.css" /> </head> <body data-theme="dark" class="notransition"> <script> const body = document.body; const data = body.getAttribute("data-theme"); const initTheme = (state) => { if (state === "dark") { body.setAttribute("data-theme", "dark"); } else if (state === "light") { body.removeAttribute("data-theme"); } else { localStorage.setItem("theme", data); } }; initTheme(localStorage.getItem("theme")); setTimeout(() => body.classList.remove("notransition"), 75); </script> <div class="navbar" role="navigation"> <nav class="menu"> <input type="checkbox" id="menu-trigger" class="menu-trigger" /> <label for="menu-trigger"> <span class="menu-icon"> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <path d="M64,384H448V341.33H64Zm0-106.67H448V234.67H64ZM64,128v42.67H448V128Z" /> </svg> </span> </label> <a id="mode"> <svg class="mode-sunny" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>LIGHT</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> <svg class="mode-moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 512 512" > <title>DARK</title> <line x1="256" y1="48" x2="256" y2="96" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="256" y1="416" x2="256" y2="464" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="108.92" x2="369.14" y2="142.86" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="369.14" x2="108.92" y2="403.08" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="464" y1="256" x2="416" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="96" y1="256" x2="48" y2="256" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="403.08" y1="403.08" x2="369.14" y2="369.14" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <line x1="142.86" y1="142.86" x2="108.92" y2="108.92" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> <circle cx="256" cy="256" r="80" style="stroke-linecap:round;stroke-miterlimit:10;stroke-width:32px" /> </svg> </a> <div class="trigger"> <div class="trigger-container"><a class="menu-link" href="/">home</a><a class="menu-link" href="/archive/">archive</a><a class="menu-link" href="/about/">about</a><a class="menu-link rss" href="/feed.xml"> <svg xmlns="http://www.w3.org/2000/svg" width="17" height="17" viewBox="0 0 512 512" fill="#ED812E" > <title>RSS</title> <path d="M108.56,342.78a60.34,60.34,0,1,0,60.56,60.44A60.63,60.63,0,0,0,108.56,342.78Z" /> <path d="M48,186.67v86.55c52,0,101.94,15.39,138.67,52.11s52,86.56,52,138.67h86.66C325.33,312.44,199.67,186.67,48,186.67Z" /> <path d="M48,48v86.56c185.25,0,329.22,144.08,329.22,329.44H464C464,234.66,277.67,48,48,48Z" /> </svg> </a> </div> </div> </nav> </div> <div class="wrapper post"> <main class="page-content" aria-label="Content"> <article itemscope itemtype="https://schema.org/BlogPosting"> <header class="header"> <h1 class="header-title" itemprop="headline">Nouveautés introduites par HTTP/3</h1> <div class="post-meta"> <time datetime="2020-05-25T01:00:00+02:00" itemprop="datePublished"> May 25, 2020 </time> <span itemprop="author" itemscope itemtype="https://schema.org/Person"> <span itemprop="name">Julie Hazan</span> </span> <time hidden datetime="" itemprop="dateModified"> May 25, 2020 </time> <span hidden itemprop="publisher" itemtype="Person">Julie Hazan</span> <span hidden itemprop="image"></span> <span hidden itemprop="mainEntityOfPage"><h1 id="http3">HTTP/3</h1> </span> </div> </header> <div class="page-content" itemprop="articleBody"> <h1 id="http3"> <a href="#http3" class="anchor-head"></a> HTTP/3 </h1> <p>HTTP/3 est la prochaine version majeure du Hypertexte Transfer Protocol qui succédera au HTTP/2. Cette nouvelle version repose sur les mêmes principes que HTTP/1 et HTTP/2 mais utilise un protocole de transport différent. Le but de ce changement est de rendre les échanges internet plus rapides et de résoudre les problèmes de pertes de paquets de manière plus performante.</p> <h2 id="background--limites-de-lhttp2"> <a href="#background--limites-de-lhttp2" class="anchor-head"></a> Background / limites de l’HTTP/2 </h2> <p>Pour comprendre ce qui a motivé le développement d’une nouvelle version HTTP, il faut connaître l’évolution de ce protocole. L’HTTP comme nous le connaissons aujourd’hui a été créé en 1996 avec le HTTP/1. Une nouvelle connexion était créée à chaque nouvel échange entre serveur et client. La création d’une connexion étant un processus coûteux, le temps de latence était donc très long pour chaque page. En plus de cela, une fois la connexion établie, il y a un temps d’attente nommé le “slow start” qui permet à l’algorithme de congestion de déterminer la quantité de données qui peut être simultanément sur le réseau sans créer de congestion. Cela évite de bloquer le réseau en lui envoyant des paquets qu’il ne peut pas gérer mais cela retarde également l’envoi d’un paquet.</p> <p>La version HTTP/1.1 cherchait à corriger ce problème en mettant en place la concept de “keep-alive”. Lorsqu’une connexion est en “keep-alive” cela signifie que la connexion doit être réutilisée pour les futurs échanges, cela évite donc d’avoir à refaire le processus relativement long de création d’une connexion. Les sites se sont mis à évoluer et à contenir plus d’informations, qui ne pouvaient pas tenir dans une seule requête. Une des solutions à ce problème était de paralléliser les requêtes venant d’une même origine mais sur des connexions différentes. Par exemple, lors d’une navigation internet, les différents fichiers d’un site sont envoyés simultanément sur 3 connexions différentes. Cela fait gagner du temps mais le concept de keep-alive perd son utilité puisqu’il faut créer plusieurs connexions pour un même échange.</p> <p>Plus tard est apparu HTTP/2 qui a introduit le principe de multiplexage. C’est-à-dire que plusieurs requêtes peuvent être faites sur la même connexion TCP. Par exemple, lorsqu’on essaye d’accéder à une page web, on a besoin d’accéder à plusieurs fichiers: des images, un fichier CSS, javascript etc… Il faut donc effectuer plusieurs requêtes. Le multiplexage permet d’effectuer ces requêtes dans la même connexion. Ce qui permet au navigateur d’afficher toutes les données du site simultanément.</p> <p><img src="https://lh6.googleusercontent.com/Y8k8S44hLu7qSQ6JOA9C715sBOT5trC9-sJZRSalDe33brEJtfNiCSx8AvLmuTQ3iGQb0MJscITJq8Gn3BwZ62rXri2IdeDqxeR8ZMCFBEBDKHlgXBsOK0zC7zqleXk97su_-hIr" alt="img" /></p> <p>Bien qu’elle permette de réduire le temps de latence, le multiplexage est limité par le TCP. En effet, à son niveau, TCP n’est pas capable de séparer les différents flux de données, c’est un protocole de transport et non d’application. Donc lorsqu’un des flux multiplexés subit une perte de paquet, c’est toute la connexion qui est bloquée jusqu’à ce que TCP fasse son travail de récupération de paquet. Cela signifie que tous les paquets, même s’ils sont déjà transmis et en attente, sont bloqués dans le tampon du nœud de destination jusqu’à ce que le paquet perdu soit retransmis.</p> <h2 id="les-améliorations-de-http3"> <a href="#les-améliorations-de-http3" class="anchor-head"></a> Les améliorations de HTTP/3 </h2> <p>La grande amélioration du HTTP/3 est l’utilisation d’un nouveau protocole de transport appelé QUIC pour Quick UDP Internet Connection, contrairement au HTTP/2 qui utilise TCP. Comme son nom l’indique, QUIC repose sur un protocole de transport déjà existant: l’UDP.</p> <p>L’avantage du UDP par rapport au TCP est sa rapidité. Le TCP a besoin de faire plusieurs allers-retours pour diffuser des données. Il est orienté « connexion ». C’est-à-dire, lorsqu’une machine A envoie des données à une machine B, la machine A doit d’abord établir une connexion avec le destinataire puis lui envoyer les données et finalement la machine B répond par un accusé réception. Ce système a un avantage parce qu’il renforce la sécurité: il permet de savoir si le destinataire a bien reçu tous les paquets dans le bon ordre et sans être corrompu. Par contre, <strong>il est assez lent</strong> puisqu’il doit faire plusieurs allers-retours.</p> <p><strong>L’UDP</strong>, au contraire, est un protocole orienté « non connexion ». Lorsqu’une machine A envoie des paquets à une machine B, le flux est unidirectionnel. La machine B n’est pas prévenue de l’arrivée des données et elle les reçoit sans avoir à envoyer d’accusé de réception. Le but du protocole QUIC (<em>Quick UDP Internet Connections</em>) c’est de conserver les avantages de l’UDP qui est plus léger que le TCP, tout en comblant l’absence de fiabilité de l’UDP.</p> <p><img src="https://lh6.googleusercontent.com/6R4bidm9vGAATqoC22qhpc1UOLtExXyJlG0QbWSNJa0NJqLYDat9N7EWLYQYP1xQIysYuBMdwcCP1EZvlg1GibzEyyk_0lafDsvFJ99-BIoDrjTkbbsJnVk8i2xWoA3DETyE13ld" alt="img" /></p> <h2 id="comment-quic-résout-ces-problèmes"> <a href="#comment-quic-résout-ces-problèmes" class="anchor-head"></a> Comment QUIC résout ces problèmes </h2> <h3 id="connexion"> <a href="#connexion" class="anchor-head"></a> Connexion </h3> <p>Comme expliqué précédemment, TCP repose sur un système de connexion. Pour démarrer une connexion, il doit y avoir un “handshake” entre le client et le serveur. À chaque fois qu’un utilisateur accède à une page web avec HTTPS, il y a un handshake. Cet échange doit respecter la norme du protocole TLS qui sert notamment à définir le mode de chiffrement à utiliser pour la communication. QUIC a mis en place un système de connexion qui est assez similaire à celui du TCP tout en réduisant le temps du handshake. Avec QUIC, la demande de connexion et de chiffrement auprès du serveurs se fait en une seule fois (ce qui demande plusieurs allers-retours au TCP). Plutôt que d’avoir plusieurs échanges au début de la connexion pour définir le mode de chiffrement de la communication, QUIC envoie les certificats et les clés nécessaires à la sécurité dans le premier paquet. Ce qui enlève donc le besoin d’avoir une négociation sur le protocole de sécurité.</p> <p>Sur ce schéma on peut voir les différentes étapes du handshake et d’une requête d’un côté pour TCP + TLS/1.3 et de l’autre la nouvelle version avec QUIC. On peut voir que le handshake en TCP se compose de 2 aller-retour alors que du côté de QUIC, il n’en suffit que d’un.</p> <p><img src="https://lh6.googleusercontent.com/nNrc_6DgyiOe-4Du4CYvALDo87U3gvWvFTKsH7KDqbH1qhjKSKI4qIyYsrgyNk8WJ4nfDC17LmoSlzF9gJ6_KenAjyM-FTVkQfh0ypu-zFFg_6blXlAlpaJJVa3-kpvCXJdIgyeX" alt="img" /></p> <h3 id="perte-de-paquet"> <a href="#perte-de-paquet" class="anchor-head"></a> Perte de paquet </h3> <p>Le deuxième problème que QUIC a réussi à résoudre est la gestion de perte de paquet. UDP n’a pas de fonction qui permette de vérifier si un paquet a bien été reçu, QUIC s’est donc inspiré du système de TCP de gestion de paquet.</p> <p><strong>QUIC n’a pas le problème d’HTTP/2 pour le multiplexage.</strong> QUIC encapsule les paquets au-dessus de la couche UDP, ce qui permet à UDP de faire une séparation entre chaque flux. Chaque flux est donc contrôlé séparément et chaque paquet perdu est retransmis au niveau de QUIC et non de UDP. Ça veut dire que si une erreur apparaît dans un flux, les autres flux peuvent continuer à être envoyés indépendamment.</p> <h3 id="chiffrement-individuel-des-paquets"> <a href="#chiffrement-individuel-des-paquets" class="anchor-head"></a> Chiffrement individuel des paquets </h3> <p>QUIC inclut également d’autres changements qui améliorent la latence. Par exemple, les paquets sont chiffrés individuellement. Il n’y a donc pas besoin d’attendre le reste des paquets pour chiffrer la communication. Cette amélioration n’est pas possible en TCP puisque le protocole de chiffrement chiffre le flux dans son ensemble et n’est pas au courant des délimitations des paquets des couches supérieures.</p> <h3 id="changement-de-réseau"> <a href="#changement-de-réseau" class="anchor-head"></a> Changement de réseau </h3> <p>Un autre objectif qu’avait QUIC était d’améliorer les performances lors d’un changement de réseau, c’est à dire lorsqu’un utilisateur mobile, par exemple, passe d’une connexion wifi à un réseau mobile. Lorsque ça arrive en TCP, une longue procédure commence où chaque connexion existante expire une par une et est ensuite rétablie par une demande. Pour corriger ce problème, QUIC inclut un identifiant de connexion pour chaque connexion au serveur, indépendamment de la source. Ça permet à la connexion d’être rétablie par le simple envoie d’un paquet avec toujours le même ID de connexion qui sera toujours valide même si l’utilisateur change d’adresse IP.</p> <h2 id="pourquoi-changer-le-protocole-http-"> <a href="#pourquoi-changer-le-protocole-http-" class="anchor-head"></a> Pourquoi changer le protocole HTTP ? </h2> <p>Nous avons vu que la grande nouveauté d’HTTP/3 concernait la couche transport. Mais s’il s’agit seulement d’un changement de transport, ne peut-on pas continuer à utiliser l’HTTP/2 avec QUIC ? Pourquoi aurait-on besoin d’un nouveau protocole d’application ?</p> <p>Il y a tout de même quelques changements à considérer du côté de l’application. Il est vrai que certaines caractéristiques de l’HTTP/2 peuvent être associées à QUIC très facilement mais ce n’est pas le cas de toutes. Par exemple, l’algorithme de compression d’HTTP/2 nommé HPACK dépend fortement de l’ordre dans lequel les différentes requêtes et réponses HTTP sont envoyées. QUIC garantie l’ordre des bytes dans un même stream mais ne garantie pas d’ordre entre les différents streams. Ce comportement nécessite la création d’un nouvel algorithme de compression qui est appelé QPACK. Ce nouvel algorithme résout le problème mais nécessite des changements sur la couche application.</p> <p>En plus de cela, certaines fonctionnalités d’HTTP/2 (comme le contrôle pour chaque flux) sera géré par QUIC et n’aura donc plus besoin d’être géré par le protocole HTTP.</p> <h2 id="les-limites-de-lhttp3"> <a href="#les-limites-de-lhttp3" class="anchor-head"></a> Les limites de l’HTTP/3 </h2> <p>Le problème le plus important auquel le protocole QUIC est confronté est la sécurité. Bien que l’authentification et le chiffrement fournissent une méthode fiable, cela pose tout de même de nouveaux problèmes. Les entêtes des paquets QUIC contiennent des informations de texte moins claires que ceux de TCP. La régulation du trafic, ou la gestion du réseau deviennent plus dur à gérer avec des connexions QUIC. Les opérateurs de réseau et les fabricants de pare-feu ont donc du mal à garantir la qualité de leur produit.</p> <p>Un autre problème concerne le contrôle de l’encombrement sur les réseaux. Ce contrôle se fait de manière automatique pour QUIC mais peut entraîner dans certains cas des taux de transmissions plus faibles qu’avec TCP.</p> <h2 id="conclusion"> <a href="#conclusion" class="anchor-head"></a> Conclusion </h2> <p>En conclusion, HTTP/3 permettra de transmettre des données plus rapidement grâce à un nouveau protocole sur la couche transport. Google a mis en pratique le protocole QUIC depuis 2015 et a estimé un gain de temps de 8 à 15% des temps de chargement des pages web. L’HTTP/3 devrait bientôt rentrer dans la norme comme l’a récemment annoncé L’IETF (<strong>Internet Engineering Task Force</strong>) et il est déjà possible de l’activer la plupart des navigateurs.</p> <h3 id="sources"> <a href="#sources" class="anchor-head"></a> Sources </h3> <ul> <li>https://www.phonandroid.com/http-3-tout-savoir-sur-le-nouveau-protocole-qui-va-accelerer-le-web.html</li> <li>https://kinsta.com/fr/blog/http3/#</li> <li>https://leblogducodeur.fr/la-difference-entre-udp-et-tcp/</li> <li>https://www.ionos.fr/digitalguide/hebergement/aspects-techniques/quic/</li> <li>https://blog.cloudflare.com/http3-the-past-present-and-future/</li> <li>https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/</li> <li>https://www.fastly.com/blog/quic-handshake-tls-compression-certificates-extension-study</li> </ul> </div> </article> </main> <nav class="post-nav"> <a class="post-nav-item post-nav-prev" href="/courbes-elliptiques/" > <div class="nav-arrow">Previous</div> <span class="post-title">Les courbes elliptiques en cryptographie</span> </a> <a class="post-nav-item post-nav-next" href="/welcome-to-jekyll/"> <div class="nav-arrow">Next</div> <span class="post-title">Welcome to Jekyll!</span> </a> </nav> <footer class="footer"> <a class="footer_item" href="/thanks">ack.</a> <a class="footer_item" href="javascript::void(0)">resume</a> <a class="footer_item" href="/feed.xml">rss</a> <span class="footer_item">&copy; 2021</span> <small class="footer_copyright"> <!-- Klisé Theme: https://github.com/piharpi/jekyll-klise --> <a href="https://github.com/piharpi/jekyll-klise" target="_blank" rel="noreferrer noopener" >klisé</a > theme on <a href="https://jekyllrb.com" target="_blank" rel="noreferrer noopener" >jekyll</a > </small> </footer> <script src="/assets/js/main.js" defer="defer"></script> </div> </body> </html>
